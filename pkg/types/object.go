package types

import (
	"fmt"
)

// Object is an instance or realization of the Spec.  It has Spec as the desired attributes, as well as,
// the instance identifier (ID), and State, which represents the current snapshot of the object instance.
type Object struct {

	// Spec is the specification / desired state of the object instance.
	Spec

	// State is the current snapshot / status of the object instance.
	State *Any `json:"state,omitempty" yaml:",omitempty"`
}

// Validate checks the object for validity
func (o Object) Validate() error {
	err := o.Spec.Validate()
	if err != nil {
		return err
	}

	if o.Metadata.Identity.UID == "" {
		return errMissingAttribute("metadata.identity.uid")
	}
	return nil
}

// ResolveDepends resolves the dependency declared in the Depends section of the Object by querying
// the index of objects and applying the json pointer to get the values.  Then the result as a map
// of key/value is returned.  The result can then be used as a template context.
func (o *Object) ResolveDepends(objects Objects,
	find func(*Object) []interface{}) (other map[string]interface{}, depends map[string]interface{}, err error) {

	depends = map[string]interface{}{}

	for _, dep := range o.Depends {

		otherObject := objects.FindBy(dep.Class, dep.Name)
		if otherObject == nil {
			return nil, nil, fmt.Errorf("unresolved dependency: %v", dep)
		}

		// Here we encode the entire other object to a map. This is because the expressions
		// used to reference values (json pointers) follow the structure of the document and not the
		// golang structs which can be different due to embedding of fields and lower-case fields.
		other = map[string]interface{}{}

		any, err := AnyValue(otherObject)
		if err != nil {
			return nil, nil, err
		}
		if err := any.Decode(&other); err != nil {
			return nil, nil, err
		}

		for key, pointer := range dep.Bind {
			depends[key] = pointer.Get(other)
		}
	}

	return
}

// Objects is a collection of instances instantiated from specs.  They are queryable via the FindBy method
type Objects interface {
	FindBy(...interface{}) *Object
}

type objectIndex map[interface{}]*Object

// FindBy returns an object matching the args
func (index objectIndex) FindBy(args ...interface{}) *Object {
	key := fmt.Sprintf("%v", args)
	return index[key]
}

// Instantiate creates an instance for each spec and returns an index where the keys are generated by the func given.
func Instantiate(specs []*Spec,
	process func(*Spec) error,
	indexKeyFunc func(*Spec) []interface{}) (Objects, error) {

	index := objectIndex{}

	for _, spec := range specs {

		if err := spec.Validate(); err != nil {
			return nil, err
		}

		if process != nil {
			if err := process(spec); err != nil {
				return nil, err
			}
		}

		key := fmt.Sprintf("%v", indexKeyFunc(spec))
		if _, has := index[key]; has {
			return nil, fmt.Errorf("duplicate key: %v", key)
		}
		index[key] = &Object{
			Spec: *spec,
		}
	}
	return index, nil
}
