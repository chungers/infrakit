package core

import (
	"fmt"

	"github.com/docker/infrakit/pkg/types"
)

// Objects is a collection of instances instantiated from specs.  They are queryable via the FindBy method
type Objects interface {
	FindBy(...interface{}) *types.Object
}

type objectIndex map[interface{}]*types.Object

// FindBy returns an object matching the args
func (index objectIndex) FindBy(args ...interface{}) *types.Object {
	key := fmt.Sprintf("%v", args)
	return index[key]
}

// Instantiate creates an instance for each spec and returns an index where the keys are generated by the func given.
func Instantiate(specs []*types.Spec,
	process func(*types.Spec) error,
	indexKeyFunc func(*types.Spec) []interface{}) (Objects, error) {

	index := objectIndex{}

	for _, spec := range specs {

		if err := spec.Validate(); err != nil {
			return nil, err
		}

		if process != nil {
			if err := process(spec); err != nil {
				return nil, err
			}
		}

		key := fmt.Sprintf("%v", indexKeyFunc(spec))
		if _, has := index[key]; has {
			return nil, fmt.Errorf("duplicate key: %v", key)
		}
		index[key] = &types.Object{
			Spec: *spec,
		}
	}
	return index, nil
}

// ResolveDepends resolves the dependency declared in the Depends section of the Object by querying
// the index of objects and applying the json pointer to get the values.  Then the result as a map
// of key/value is returned.  The result can then be used as a template context.
func ResolveDepends(o *types.Object, objects Objects,
	find func(*types.Object) []interface{}) (other map[string]interface{}, depends map[string]interface{}, err error) {

	depends = map[string]interface{}{}

	for _, dep := range o.Depends {

		otherObject := objects.FindBy(dep.Class, dep.Name)
		if otherObject == nil {
			return nil, nil, fmt.Errorf("unresolved dependency: %v", dep)
		}

		// Here we encode the entire other object to a map. This is because the expressions
		// used to reference values (json pointers) follow the structure of the document and not the
		// golang structs which can be different due to embedding of fields and lower-case fields.
		other = map[string]interface{}{}

		any, err := types.AnyValue(otherObject)
		if err != nil {
			return nil, nil, err
		}
		if err := any.Decode(&other); err != nil {
			return nil, nil, err
		}

		for key, pointer := range dep.Bind {
			depends[key] = pointer.Get(other)
		}
	}
	return
}
